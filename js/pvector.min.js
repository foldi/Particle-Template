PVector = (function () {

	function clone (object) {
		function F() {}
		F.prototype = object;
		return F;
	}
	function PVectorAdd (v1, v2) {
		return PVector.create(v1.x + v2.x, v1.y + v2.y);
	}
	function PVectorSub (v1, v2) {
		return PVector.create(v1.x - v2.x, v1.y - v2.y);
	}
	function PVectorDiv (v1, v2) {
		return PVector.create(v1.x / v2.x, v1.y / v2.y);
	}

	return {
		clone: function () {
			function F() {}
			F.prototype = this;
			return new F;
		},
		create: function (x, y) {
			var obj, F = clone(this);
			obj = new F;
			obj.x = x;
			obj.y = y;
			return obj;
		},
		add: function(v) {
			this.x += v.x;
			this.y += v.y;
			return this;
		},
		sub: function(v) {
			this.x -= v.x;
			this.y -= v.y;
			return this;
		},	
		mult: function(n) {
			this.x *= n;
			this.y *= n;
			return this;
		},	
		div: function(n) {
			this.x = this.x / n;
			this.y = this.y / n;
			return this;
		},
		mag: function() {
			return Math.sqrt((this.x * this.x) + (this.y * this.y));
		},
		limit: function (high) {
			if (this.mag() > high) {
				this.normalize();
				this.mult(high);
			}
		},
		normalize: function () {
			m = this.mag();
			if (m !== 0) {
				return this.div(m);
			}
		},						
		distance: function(v) {
			var x = this.x - v.x,
			y = this.y - v.y;
			return Math.sqrt(x * x + y * y);
		},
		length: function() {
			return Math.sqrt(this.x * this.x + this.y * this.y);
		},
		rotate: function(rad) {
			var cos = Math.cos(rad), sin = Math.sin(rad), x = this.x, y = this.y;
			this.x = x * cos - y * sin;
			this.y = x * sin + y * cos;
			return this;
		},
		midpoint: function (v1, v2) {
			return PVectorAdd(v1, v2).div(2); // midpoint = (v1 + v2)/2
		},
		distance: function (v1, v2) {
			return Math.sqrt(Math.pow(v2.x - v1.x, 2) + Math.pow(v2.y - v1.y, 2));
		},
		dot: function (v) {
			if (this.z && v.z) {
				return this.x*v.x + this.y*v.y + this.z*v.z;
			}
			return this.x*v.x + this.y*v.y;
		}
	};
}());